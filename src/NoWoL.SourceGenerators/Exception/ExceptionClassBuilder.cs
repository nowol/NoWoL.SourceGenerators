using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;

namespace NoWoL.SourceGenerators
{
    internal class ExceptionClassBuilder
    {
        internal void GenerateException(IndentedStringBuilder sb, ref ExceptionClassDefinition classDefinition)
        {
            sb.AddRaw(GenerationHelpers.AutoGeneratedHeader);
            
            GenericClassBuilder.WriteClassStart(sb,
                                               classDefinition.ClassDef,
                                               classDefinition.Namespace!,
                                               classDefinition.ParentClasses);
            
            AddExceptionBody(sb,
                             ref classDefinition);

            GenericClassBuilder.WriteClassEnd(sb);
        }

        private void AddExceptionBody(IndentedStringBuilder sb, ref ExceptionClassDefinition classDefinition)
        {
            var className = classDefinition.ClassDef.Name;

            sb.Add($@"    {SimpleCounter.GetValue()}[System.Serializable]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    {CodeGenAttribute}
    {GenerationHelpers.BuildClassDefinition(classDefinition.ClassDef.Name, classDefinition.ClassDef.Modifier)} : System.Exception
    {{
        /// <summary>
        /// Creates an instance of the <see cref=""{className}""/> class.
        /// </summary>
        public {className}()
        {{}}

        /// <summary>
        /// Creates an instance of the <see cref=""{className}""/> class.
        /// </summary>
        /// <param name=""message"">Message of the exception</param>
        public {className}(string message)
            : base(message)
        {{}}

        /// <summary>
        /// Creates an instance of the <see cref=""{className}""/> class.
        /// </summary>
        /// <param name=""message"">Message of the exception</param>
        /// <param name=""innerException"">Optional inner exception</param>
        public {className}(string message, System.Exception innerException)
            : base(message, innerException)
        {{}}

        /// <summary>
        /// Initializes a new instance of the <see cref=""{className}""/> class.
        /// </summary>
        /// <param name=""info"">Serialization info</param>
        /// <param name=""context"">Serialization context</param>
        protected {className}(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
            : base(info, context)
        {{
        }}", removeLastNewLines: true, addNewLine: true);

            AddExceptionHelpers(sb, ref classDefinition);

            sb.Add(@"
    }", addNewLine: true);
        }

        private static readonly string CodeGenAttribute = GetCodeGenAttribute();

        private static string GetCodeGenAttribute()
        {
            return $@"[System.CodeDom.Compiler.GeneratedCodeAttribute(""{nameof(ExceptionClassGenerator)}"", ""{typeof(ExceptionClassGenerator).Assembly.GetName().Version}"")]";
        }

        private static readonly Regex FormatterRegex = new Regex(@"\{(?<Formatter><[^<>{}]+>)?\s*(?<DataType>[^ {}]+)\s+(?<ParamName>[^{}]+)\}", RegexOptions.Compiled);

        private void AddExceptionHelpers(IndentedStringBuilder sb, ref ExceptionClassDefinition classDefinition)
        {
            var className = classDefinition.ClassDef.Name;

            if (classDefinition.Messages == null || classDefinition.Messages.Count == 0)
            {
                return;
            }

            var parameters = new List<(string type, string name)>();
            foreach (var standardMessage in classDefinition.Messages)
            {
                parameters.Clear();

                var template = FormatterRegex.Replace(standardMessage,
                                                      ReplaceParameterMatch);
                var methodParameters = parameters.Count == 0 ?
                                           String.Empty :
                                           String.Join(", ", parameters.Select(x => $"{x.type} {x.name}"));

                sb.Add(Create(template, methodParameters),
                       removeLastNewLines: true,
                       addNewLine: true);

                sb.Add(CreateMessage(template, methodParameters),
                       removeLastNewLines: true,
                       addNewLine: true);
            }

            string Create(string template, string methodParameters)
            {
                return $@"

        /// <summary>
        /// Helper method to create the exception
        /// </summary>
        /// <param name=""innerException"">Optional inner exception</param>
        /// <returns>An instance of the <see cref=""{className}""/> exception</returns>
        public static {className} Create({methodParameters}{(String.IsNullOrWhiteSpace(methodParameters) ? "" : ", ")}System.Exception innerException = null)
        {{
            return new {className}($""{template}"", innerException);
        }}";
            }

            string CreateMessage(string template, string methodParameters)
            {
                return $@"

        /// <summary>
        /// Helper method to create the exception's message
        /// </summary>
        /// <returns>An string with the message of the <see cref=""{className}""/> exception</returns>
        public static string CreateMessage({methodParameters})
        {{
            return $""{template}"";
        }}";
            }

            string ReplaceParameterMatch(Match match)
            {
                {
                    var dataType = match.Groups["DataType"].Value;
                    var name = match.Groups["ParamName"].Value;

                    parameters.Add((dataType, name));

                    if (match.Groups["Formatter"].Success)
                    {
                        var formatter = match.Groups["Formatter"].Value.Trim(new[] { '<', '>' });

                        return "{" + formatter + "(" + name + ")" + "}";
                    }

                    return "{" + name + "}";
                }
            }
        }
    }
}